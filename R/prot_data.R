#' ProtData Class
#'
#' An S4 class that holds proteomics data and provides methods for processing.
#'
#' @export
setClass("ProtData",
         slots = list(
           data = "data.frame",      # The main proteomics data (proteins are rows, samples are columns)
           condition = "data.frame",  # Conditions of the samples. Rownames must match colnames of data
           prot_meta = "data.frame",  # information about the rows (genes, organism, etc...)
           method = "character"       # The method used (e.g., "MS", "Somascan", etc.)
         ),
         prototype = list(
           data = data.frame(),        # Default is an empty data frame
           condition = data.frame(),   # Default is an empty data frame
           prot_meta = data.frame(),   # Default is an empty data frame
           method = "Unknown"          # Default method is set to "Unknown"
         )
)


# Constructor for ProtData class
#' Create a ProtData Object
#'
#' This function creates an instance of the ProtData class.
#'
#' @param data A data frame containing proteomics data (proteins are rows, samples are columns).
#' @param condition A data frame containing conditions of the samples. Rownames should match colnames of data. Optional.
#' @param prot_meta A data frame containing metadata for the proteins (rows). Optional.
#' @param method A character string describing the method used for generating the data. Optional.
#'
#' @return An instance of the ProtData class.
#' @export
create_protdata <- function(dat, intensity_cols, condition = NULL, method = "Unknown") {

  # Check that data is a data frame
  if (!is.data.frame(dat)) {
    stop("The 'data' argument must be a data frame.")
  }


  #standardize the column names and order
  #dat <- standardize_format(data)
  colnames(dat) <- trim_colnames(dat)
  # col_order=c(colnames(dat)[1:2],sort(colnames(dat)[3:ncol(dat)]))
  # data.table::setcolorder(dat,col_order)

  # This should be a seperate function
  # dat <- dat %>%
  #   # Calculte missing values
  #   dplyr::mutate(missing_value = rowSums(is.na(dplyr::select(., -contains("Protein_Group|Genes")))))%>%
  #   # Calculate median values
  #   dplyr::mutate(median = matrixStats::rowMedians(as.matrix(dplyr::select(., -contains("Protein_Group|Genes|missing_value")) %>%
  #                                          dplyr::select_if(is.numeric)), na.rm = TRUE)) %>%
  #   #Identify unique Protein_Group with the least missing values and highest median intensity
  #   dplyr::group_by(Protein_Group) %>%
  #   dplyr::filter(missing_value == min(missing_value)) %>%
  #   dplyr::slice(which.max(median)) %>%
  #   dplyr::ungroup() %>%
  #   dplyr::select(-c(missing_value, median))

  #Split up intensity and non-numeric protein metadata into seperate dataframes
  prot_meta <- as.data.frame(dat[, -intensity_cols])
  data <- as.data.frame(dat[, intensity_cols])
  data <- data %>%
    dplyr::mutate(dplyr::across(dplyr::everything(), ~ as.numeric(.)))

  ## CONDITION FILE ###################

  # Ensure that condition, if provided, has rownames matching the colnames of data
  if (!is.null(condition)) {
    # make sample col the rownames if it exists
    if ("sample" %in% colnames(condition)) {
      rownames(condition) <- condition$sample
      condition$sample <- NULL
    }

    # drop excess rows from the condition file if they exist
    if (!all(rownames(condition) %in% colnames(data))) {
      print("Rownames of 'condition' do not match the colnames of 'data'.")

      # Drop rows of condition that are not in data
      matching_rows <- intersect(rownames(condition), colnames(data))
      condition <- condition[matching_rows, ]

      dropped_rows <- setdiff(rownames(condition), matching_rows)
      warning("Dropped rows:\n")
      warning(dropped_rows)
    }
    # add additional rows to condition if they exist in data
    if (ncol(data) > nrow(condition)) {
      # Find missing columns
      missing_cols <- setdiff(colnames(data), rownames(condition))

      # Create rows with NA for the missing columns and add them to 'condition'
      missing_rows <- data.frame(matrix(NA, nrow = length(missing_cols), ncol = ncol(condition)))
      colnames(missing_rows) <- names(condition)
      rownames(missing_rows) <- missing_cols

      # Add missing rows to 'condition'
      condition <- rbind(condition, missing_rows)
    }

    # Reorder 'condition' to match the order of 'data' columns
    condition <- condition[match(colnames(data), rownames(condition)), , drop = FALSE]
  }

  # if condition file is not provided, one is generated by removing _{replicate number} from each
  # sample name if present
  else {
    condition <- data.frame(
      base_condition = gsub("_\\d+$", "", colnames(data))  # Remove _ followed by digits at the end of the column names
    )
    rownames(condition) <- colnames(data)
  }


  # Create a new ProtData object
  new("ProtData",
      data = data,
      condition = condition,
      prot_meta = prot_meta,
      method = method)
}


####### GETTERS and SETTERS ###############################################################

# Define the generic for 'getData'
setGeneric("getData", function(object) standardGeneric("getData"))

# Define the setter for 'getData'
setGeneric("setData", function(object, value) standardGeneric("setData"))

# Now define the method for 'getData' for the ProtData class
setMethod("getData", "ProtData", function(object) {
  return(object@data)
})

# Define the setter method for 'setData' for ProtData
setMethod("setData", "ProtData", function(object, value) {
  if (!inherits(value, "data.table")) {
    stop("'data' must be a data.table.")
  }
  object@data <- value
  return(object)
})

# Define the generic for 'data.long'
setGeneric("getDataLong", function(object) standardGeneric("getDataLong"))
setGeneric("setDataLong", function(object, value) standardGeneric("setDataLong"))

# Define the methods for 'data.long' for ProtData
setMethod("getDataLong", "ProtData", function(object) {
  return(object@data.long)
})

setMethod("setDataLong", "ProtData", function(object, value) {
  if (!inherits(value, "data.table")) {
    stop("'data.long' must be a data.table.")
  }
  object@data.long <- value
  return(object)
})

# Similarly, define getter and setter for 'condition'
setGeneric("getCondition", function(object) standardGeneric("getCondition"))
setGeneric("setCondition", function(object, value) standardGeneric("setCondition"))

setMethod("getCondition", "ProtData", function(object) {
  return(object@condition)
})

setMethod("setCondition", "ProtData", function(object, value) {
  if (!inherits(value, "data.frame")) {
    stop("'condition' must be a data.frame.")
  }
  object@condition <- value
  return(object)
})

# Similarly, define getter and setter for 'prot_meta'
setGeneric("getProtMeta", function(object) standardGeneric("getProtMeta"))
setGeneric("setProtMeta", function(object, value) standardGeneric("setProtMeta"))

setMethod("getProtMeta", "ProtData", function(object) {
  return(object@prot_meta)
})

setMethod("setProtMeta", "ProtData", function(object, value) {
  if (!inherits(value, "data.table")) {
    stop("'prot_meta' must be a data.table.")
  }
  object@prot_meta <- value
  return(object)
})

# Similarly, define getter and setter for 'method'
setGeneric("getProtMethod", function(object) standardGeneric("getProtMethod"))
setGeneric("setProtMethod", function(object, value) standardGeneric("setProtMethod"))

#WHY DOESNT THIS WORK????
setMethod("getProtMethod", "ProtData", function(object) {
  return(object@method)
})

setMethod("setProtMethod",
          signature = c(object = "ProtData", value = "character"),
          function(object, value) {
            if (length(value) != 1) {
              stop("'method' must be a single character string.")
            }
            object@method <- value
            return(object)
          })

####### Some Class Methods ###############################################################

#' Title
#'
#' @param object
#'
#' @return
#' @export
#'
#' @examples
setGeneric("num_samples", function(object) standardGeneric("num_samples"))
setMethod("num_samples", "ProtData", function(object) {
  return(as.numeric(ncol(object@data)))
})

#' Title
#'
#' @param object
#'
#' @return
#' @export
#'
#' @examples
setGeneric("log2_transform", function(object) standardGeneric("log2_transform"))
setMethod("log2_transform", "ProtData", function(object) {
  object@data <- object@data %>%
    dplyr::mutate(across(where(is.numeric), ~ ifelse(!is.na(.) & !is.nan(.), log2(.+1), .)))
  return(object)
})

#' Title
#'
#' @param object
#'
#' @return
#' @export
#'
#' @examples
setGeneric("log_transform", function(object) standardGeneric("log_transform"))
setMethod("log_transform", "ProtData", function(object) {
  object@data <- object@data %>%
    dplyr::mutate(across(where(is.numeric), ~ ifelse(!is.na(.) & !is.nan(.), log(.+1), .)))
  return(object)
})

#' Title
#'
#' @param object
#'
#' @return
#' @export
#'
#' @examples
setGeneric("scale", function(object) standardGeneric("scale"))
setMethod("scale", "ProtData", function(object) {
  object@data <- t(base::scale(t(object@data)))%>%
    as.data.frame()
  return(object)
})


#' Title
#'
#' @param object
#'
#' @return
#' @export
#'
#' @examples
setGeneric("median_normalize", function(object) standardGeneric("median_normalize"))
setMethod("median_normalize", "ProtData", function(object) {
  object@data <- t(apply(object@data, 1, function(x) x / median(x, na.rm = TRUE))) %>%
    as.data.frame()
  return(object)
})

#' Title
#'
#' @param object
#' @param value
#'
#' @return
#' @export
#'
#' @examples
setGeneric("impute", function(object, value) standardGeneric("impute"))
setMethod("impute", "ProtData", function(object, value) {
  object@data <- object@data %>%
    mutate(across(where(is.numeric), ~ ifelse(is.na(.) | is.nan(.), value, .)))
  return(object)
})


#' Title
#'
#' @param object
#' @param value
#'
#' @return
#' @export
#'
#' @examples
setGeneric("impute_min", function(object, value) standardGeneric("impute_min"))
setMethod("impute_min", "ProtData", function(object, value) {
  object@data <- t(apply(object@data, 1, function(x) {
    min_val <- min(x[!is.na(x) & !is.nan(x)], na.rm = TRUE)  # find the minimum value excluding NA and NaN
    x[is.na(x) | is.nan(x)] <- min_val  # replace NA and NaN with the minimum value
    return(x)
  })) %>% as.data.frame()
  return(object)
})

#' Title
#'
#' @param object
#' @param col
#'
#' @return
#' @export
#'
#' @examples
setGeneric("batch_correct", function(object, col) standardGeneric("batch_correct"))
setMethod("batch_correct", "ProtData", function(object, col) {
  object@data <- object@data %>%
    limma::removeBatchEffect(batch = object@condition[[col]]) %>%
    as.data.frame()
  return(object)
})




######## HELPER FUNCTIONS ####################################################################

#total proteomics############
standardize_format <- function(DT.original) {
  # Accepts an input protein group intensity data.table, whether spectronaut or DIA-NN format,
  # and restructures into one consistent style for downstream processing
  DT <- DT.original
  if("Protein.Ids" %in% colnames(DT) | "Protein.Group" %in% colnames(DT)) {
    # print("DIAnn input")
    # DT[, 'Protein.Ids' := NULL]
    # DT[, 'Protein.Names' := NULL]
    # DT[, 'First.Protein.Description' := NULL]
    data.table::setnames(DT, 'Protein.Group', 'Protein_Group')
  }
  else if('EG.PrecursorId' %in% colnames(DT)) {
    print("Spectronaut input")
    data.table::setnames(DT, 'EG.PrecursorId', 'Peptide_Sequence')
    data.table::setnames(DT, 'PG.Genes', 'Genes')
    DT=as.data.frame(DT)
    # Use only Protein_Group and Genes
    dplyr::select=c('Peptide_Sequence','Genes',grep('raw',colnames(DT),value = T))
    DT=DT[, dplyr::select]
    #as number
    DT[,grep('raw',colnames(DT))]=as.data.frame(apply(DT[,grep('raw',colnames(DT))],2,as.numeric))
    DT=data.table(DT)
  }
  else if('PG.ProteinGroups' %in% colnames(DT)) {
    print("Spectronaut input")
    data.table::setnames(DT, 'PG.ProteinGroups', 'Protein_Group')
    data.table::setnames(DT, 'PG.Genes', 'Genes')
    DT=as.data.frame(DT)
    # Use only Protein_Group and Genes
    dplyr::select=c('Protein_Group','Genes',grep('PG.Quantity',colnames(DT),value = T))
    DT=DT[, dplyr::select]
    #as number
    DT[,grep('PG.Quantity',colnames(DT))]=as.data.frame(apply(DT[,grep('PG.Quantity',colnames(DT))],2,as.numeric))
    DT=data.table(DT)
  }
  else if('Peptide Sequence' %in% colnames(DT)) {
    print("FragPipe input")
    data.table::setnames(DT, 'Gene', 'Genes')
    colnames(DT)=gsub("\\s", "_",colnames(DT))
    # Use only Protein_Group and Genes
    DT=as.data.frame(DT)
    dplyr::select=c('Peptide_Sequence','Genes',grep('[0-9]_Intensity',colnames(DT),value = T))
    DT=DT[, dplyr::select]
    DT=data.table(DT)
  }

  # Remove leading directories for sample names
  # e.g. /path/to/sample1.mzML -> sample1.mzML
  data.table::setnames(DT, basename(colnames(DT)))

  # Remove trailing file extensions
  extensions <- '.mzML$|.mzml$|.RAW$|.raw$|.dia$|.DIA$|_Intensity'
  extension_samplenames <-  colnames(DT)[data.table::`%like%`(colnames(DT), extensions)]
  trimmed_samplenames <- gsub(extensions, '', extension_samplenames)
  data.table::setnames(DT, extension_samplenames, trimmed_samplenames)
  return(DT[])
}

trim_colnames <- function(DT) {
  colnames_out <- gsub(pattern="\\[.*\\] ", replacement='', x=colnames(DT))   # trim leading [N]
  colnames_out <- gsub(pattern="\\..*\\.PG\\.Quantity|\\.PG\\.Quantity|\\..*Quantity.*", replacement='', x=colnames_out)   # remove suffix
  # Remove everything before the last "/" and remove extensions like .raw or .mzml
  colnames_out <- gsub(pattern=".*/", replacement='', x=colnames_out)
  colnames_out <- gsub(pattern="\\.(raw|mzML)$", replacement='', x=colnames_out)
  return(colnames_out)
}

#create long data table
melt_intensity_table <- function(DT) {
  # Converts intensity data.table to long format
  # info_cols <- c('Protein_Group', 'Genes', 'First_Protein_Description')
  DT.long <- reshape2::melt(DT,
                  measure.vars=names(DT)[sapply(DT, function(x) all(is.numeric(x)))],
                  variable.name='Sample',
                  value.name='Intensity')
  DT.long=data.table::data.table(DT.long)
  DT.long=DT.long[DT.long$Intensity>0,]
  return(DT.long)
}

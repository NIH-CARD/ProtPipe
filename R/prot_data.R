#' ProtData Class
#'
#' An S4 class that holds proteomics data and provides methods for processing.
#'
#' @export
setClass("ProtData",
         slots = list(
           data = "data.table",      # The main proteomics data (proteins are rows, samples are columns)
           data.long = "data.table",
           condition = "data.frame",  # Conditions of the samples. Rownames must match colnames of data
           prot_meta = "data.table",  # information about the rows (genes, organism, etc...)
           method = "character"       # The method used (e.g., "MS", "Somascan", etc.)
         ),
         prototype = list(
           data = data.table::data.table(),        # Default is an empty data frame
           data.long = data.table::data.table(),   # Default is an empty data frame
           condition = data.frame(),   # Default is an empty data frame
           prot_meta = data.table::data.table(),   # Default is an empty data frame
           method = "Unknown"          # Default method is set to "Unknown"
         )
)



# Constructor for ProtData class
#' Create a ProtData Object
#'
#' This function creates an instance of the ProtData class.
#'
#' @param data A data frame containing proteomics data (proteins are rows, samples are columns).
#' @param condition A data frame containing conditions of the samples. Rownames should match colnames of data. Optional.
#' @param prot_meta A data frame containing metadata for the proteins (rows). Optional.
#' @param method A character string describing the method used for generating the data. Optional.
#'
#' @return An instance of the ProtData class.
#' @export
create_protdata <- function(data, condition = NULL, method = "Unknown") {

  # Check that data is a data frame
  if (!is.data.frame(data)) {
    stop("The 'data' argument must be a data frame.")
  }

  #standardize the column names and order
  #dat <- standardize_format(data)
  colnames(dat) <- trim_colnames(dat)
  # col_order=c(colnames(dat)[1:2],sort(colnames(dat)[3:ncol(dat)]))
  # data.table::setcolorder(dat,col_order)

  # This should be a seperate function
  # dat <- dat %>%
  #   # Calculte missing values
  #   dplyr::mutate(missing_value = rowSums(is.na(dplyr::select(., -contains("Protein_Group|Genes")))))%>%
  #   # Calculate median values
  #   dplyr::mutate(median = matrixStats::rowMedians(as.matrix(dplyr::select(., -contains("Protein_Group|Genes|missing_value")) %>%
  #                                          dplyr::select_if(is.numeric)), na.rm = TRUE)) %>%
  #   #Identify unique Protein_Group with the least missing values and highest median intensity
  #   dplyr::group_by(Protein_Group) %>%
  #   dplyr::filter(missing_value == min(missing_value)) %>%
  #   dplyr::slice(which.max(median)) %>%
  #   dplyr::ungroup() %>%
  #   dplyr::select(-c(missing_value, median))

  dat.long <- melt_intensity_table(dat)
  dat.long <- dat.long[rowSums(is.na(dat.long)) < ncol(dat.long),]
  #dat.long <- dat.long[! is.na(Intensity)][Intensity != 0]
  #filter intensity
  #dat.long <- dat.long[Intensity > opt$minintensity]

  #Split up numeric (intensity) and non-numeric (protein metadata) into seperate dataframes
  prot_meta <- as.data.frame(dat[, !sapply(dat, is.numeric)])
  data <- as.data.frame(dat[, sapply(dat, is.numeric)])

  ## CONDITION FILE ###################

  # Ensure that condition, if provided, has rownames matching the colnames of data
  if (!is.null(condition)) {
    if (!all(rownames(condition) %in% colnames(data))) {
      stop("Rownames of 'condition' must match the colnames of 'data'.")
    }
    # add additional rows to condition if they exist in data
    if (ncol(data) > nrow(condition)) {
      # Find missing columns
      missing_cols <- setdiff(colnames(data), rownames(condition))

      # Create rows with NA for the missing columns and add them to 'condition'
      missing_rows <- data.table(matrix(NA, nrow = length(missing_cols), ncol = ncol(condition)))
      setnames(missing_rows, names(condition))
      rownames(missing_rows) <- missing_cols

      # Add missing rows to 'condition'
      condition <- rbind(condition, missing_rows)
    }

    # Reorder 'condition' to match the order of 'data' columns
    condition <- condition[match(colnames(data), rownames(condition)), , drop = FALSE]
  }

  # if condition file is not provided, one is generated by removing _{replicate number} from each
  # sample name if present
  else {
    condition <- data.frame(
      base_condition = gsub("_\\d+$", "", colnames(data))  # Remove _ followed by digits at the end of the column names
    )
    rownames(condition) <- colnames(data)
  }


  # Create a new ProtData object
  new("ProtData",
      data = data.table::as.data.table(data),
      data.long = dat.long,
      condition = condition,
      prot_meta = data.table::as.data.table(prot_meta),
      method = method)
}


####### GETTERS and SETTERS ###############################################################

# Define the generic for 'getData'
setGeneric("getData", function(object) standardGeneric("getData"))

# Define the setter for 'getData'
setGeneric("setData", function(object, value) standardGeneric("setData"))

# Now define the method for 'getData' for the ProtData class
setMethod("getData", "ProtData", function(object) {
  return(object@data)
})

# Define the setter method for 'setData' for ProtData
setMethod("setData", "ProtData", function(object, value) {
  if (!inherits(value, "data.table")) {
    stop("'data' must be a data.table.")
  }
  object@data <- value
  return(object)
})

# Define the generic for 'data.long'
setGeneric("getDataLong", function(object) standardGeneric("getDataLong"))
setGeneric("setDataLong", function(object, value) standardGeneric("setDataLong"))

# Define the methods for 'data.long' for ProtData
setMethod("getDataLong", "ProtData", function(object) {
  return(object@data.long)
})

setMethod("setDataLong", "ProtData", function(object, value) {
  if (!inherits(value, "data.table")) {
    stop("'data.long' must be a data.table.")
  }
  object@data.long <- value
  return(object)
})

# Similarly, define getter and setter for 'condition'
setGeneric("getCondition", function(object) standardGeneric("getCondition"))
setGeneric("setCondition", function(object, value) standardGeneric("setCondition"))

setMethod("getCondition", "ProtData", function(object) {
  return(object@condition)
})

setMethod("setCondition", "ProtData", function(object, value) {
  if (!inherits(value, "data.frame")) {
    stop("'condition' must be a data.frame.")
  }
  object@condition <- value
  return(object)
})

# Similarly, define getter and setter for 'prot_meta'
setGeneric("getProtMeta", function(object) standardGeneric("getProtMeta"))
setGeneric("setProtMeta", function(object, value) standardGeneric("setProtMeta"))

setMethod("getProtMeta", "ProtData", function(object) {
  return(object@prot_meta)
})

setMethod("setProtMeta", "ProtData", function(object, value) {
  if (!inherits(value, "data.table")) {
    stop("'prot_meta' must be a data.table.")
  }
  object@prot_meta <- value
  return(object)
})

# Similarly, define getter and setter for 'method'
setGeneric("getProtMethod", function(object) standardGeneric("getProtMethod"))
setGeneric("setProtMethod", function(object, value) standardGeneric("setProtMethod"))

#WHY DOESNT THIS WORK????
setMethod("getProtMethod", "ProtData", function(object) {
  return(object@method)
})

setMethod("setProtMethod",
          signature = c(object = "ProtData", value = "character"),
          function(object, value) {
            if (length(value) != 1) {
              stop("'method' must be a single character string.")
            }
            object@method <- value
            return(object)
          })

####### Class Methods ###############################################################

setGeneric("removeOutliers", function(object, sds = 3) standardGeneric("removeOutliers"))
setMethod("removeOutliers",
          "ProtData",
          function(object, sds = 3){
            pgcounts <- data.table::as.data.table(table(getDataLong(object)$Sample))
            colnames(pgcounts) <- c("Sample", "N")
            pgcounts$Condition=as.factor(gsub('_[0-9]+$','',pgcounts$Sample))
            dat <- getData(object)
            dat.long <- getDataLong(object)
            condition <- getCondition(object)

            stdev <- sd(pgcounts[,'N'])
            mean_count <- mean(pgcounts[,'N'])
            min_protein_groups <- floor(mean_count - (sds * stdev))
            max_protein_groups <- ceiling(mean_count + (sds * stdev))
            cat(paste0('INFO: Tolerating protein group counts in the range [', min_protein_groups,',',max_protein_groups,']'))
            low_count_samples <- as.character(pgcounts['N' < min_protein_groups, 'Sample'])
            high_count_samples <- as.character(pgcounts['N' > max_protein_groups, 'Sample'])
            if(length(low_count_samples)==0) {
              cat('\nINFO: No low group count samples to remove\n')
            } else {
              cat(paste0('\nINFO: runing low-count outlier ', low_count_samples))
              cat('\n\n')
              print(pgcounts[Sample %in% low_count_samples])
              cat('\n')
              dat[, colnames(dat) %in% low_count_samples]= NULL    # remove sample columns from wide table
              dat.long <- dat.long[! (Sample %in% low_count_samples)] # remove rows from long table
            }
            if(length(high_count_samples)==0) {
              cat('INFO: No high group count samples to remove\n')
            } else {
              cat(paste0('\nINFO: runing high-count outlier ', high_count_samples))
              cat('\n')
              #print(pgcounts['Sample' %in% high_count_samples])
              dat[, colnames(dat) %in% high_count_samples]= NULL     # remove sample columns from wide table
              dat.long <- dat.long[! ('Sample' %in% high_count_samples)] # remove rows from long table
            }
            object <- setData(object, dat)
            object <- setDataLong(object, dat.long)
            #object <- setCondition(object, condition)
            return(object)
          }
      )

setGeneric("removeSample", function(object, samples) standardGeneric("removeSample"))
setMethod("removeSample",
          "ProtData",
          function(object, samples){
            dat <- getData(object)
            dat.long <- getDataLong(object)
            condition <- getCondition(object)

            dat <- dat[,!(colnames(dat) %in% samples)]
            dat.long <- dat.long[!'Sample' %in% samples]
            condition <-condition[!(rownames(condition) %in% samples),]

            object <- setData(object, dat)
            object <- setDataLong(object, dat.long)
            object <- setCondition(object, condition)
            return(object)
          }
)




######## HELPER FUNCTIONS ####################################################################

#total proteomics############
standardize_format <- function(DT.original) {
  # Accepts an input protein group intensity data.table, whether spectronaut or DIA-NN format,
  # and restructures into one consistent style for downstream processing
  DT <- DT.original
  if("Protein.Ids" %in% colnames(DT) | "Protein.Group" %in% colnames(DT)) {
    # print("DIAnn input")
    # DT[, 'Protein.Ids' := NULL]
    # DT[, 'Protein.Names' := NULL]
    # DT[, 'First.Protein.Description' := NULL]
    data.table::setnames(DT, 'Protein.Group', 'Protein_Group')
  }
  else if('EG.PrecursorId' %in% colnames(DT)) {
    print("Spectronaut input")
    data.table::setnames(DT, 'EG.PrecursorId', 'Peptide_Sequence')
    data.table::setnames(DT, 'PG.Genes', 'Genes')
    DT=as.data.frame(DT)
    # Use only Protein_Group and Genes
    dplyr::select=c('Peptide_Sequence','Genes',grep('raw',colnames(DT),value = T))
    DT=DT[, dplyr::select]
    #as number
    DT[,grep('raw',colnames(DT))]=as.data.frame(apply(DT[,grep('raw',colnames(DT))],2,as.numeric))
    DT=data.table(DT)
  }
  else if('PG.ProteinGroups' %in% colnames(DT)) {
    print("Spectronaut input")
    data.table::setnames(DT, 'PG.ProteinGroups', 'Protein_Group')
    data.table::setnames(DT, 'PG.Genes', 'Genes')
    DT=as.data.frame(DT)
    # Use only Protein_Group and Genes
    dplyr::select=c('Protein_Group','Genes',grep('PG.Quantity',colnames(DT),value = T))
    DT=DT[, dplyr::select]
    #as number
    DT[,grep('PG.Quantity',colnames(DT))]=as.data.frame(apply(DT[,grep('PG.Quantity',colnames(DT))],2,as.numeric))
    DT=data.table(DT)
  }
  else if('Peptide Sequence' %in% colnames(DT)) {
    print("FragPipe input")
    data.table::setnames(DT, 'Gene', 'Genes')
    colnames(DT)=gsub("\\s", "_",colnames(DT))
    # Use only Protein_Group and Genes
    DT=as.data.frame(DT)
    dplyr::select=c('Peptide_Sequence','Genes',grep('[0-9]_Intensity',colnames(DT),value = T))
    DT=DT[, dplyr::select]
    DT=data.table(DT)
  }

  # Remove leading directories for sample names
  # e.g. /path/to/sample1.mzML -> sample1.mzML
  data.table::setnames(DT, basename(colnames(DT)))

  # Remove trailing file extensions
  extensions <- '.mzML$|.mzml$|.RAW$|.raw$|.dia$|.DIA$|_Intensity'
  extension_samplenames <-  colnames(DT)[data.table::`%like%`(colnames(DT), extensions)]
  trimmed_samplenames <- gsub(extensions, '', extension_samplenames)
  data.table::setnames(DT, extension_samplenames, trimmed_samplenames)
  return(DT[])
}

trim_colnames <- function(DT) {
  colnames_out <- gsub(pattern="\\[.*\\] ", replacement='', x=colnames(DT))   # trim leading [N]
  colnames_out <- gsub(pattern="\\..*\\.PG\\.Quantity|\\.PG\\.Quantity|\\..*Quantity.*", replacement='', x=colnames_out)   # remove suffix
  # Remove everything before the last "/" and remove extensions like .raw or .mzml
  colnames_out <- gsub(pattern=".*/", replacement='', x=colnames_out)
  colnames_out <- gsub(pattern="\\.(raw|mzml)$", replacement='', x=colnames_out)
  return(colnames_out)
}

#create long data table
melt_intensity_table <- function(DT) {
  # Converts intensity data.table to long format
  # info_cols <- c('Protein_Group', 'Genes', 'First_Protein_Description')
  DT.long <- reshape2::melt(DT,
                  measure.vars=names(DT)[sapply(DT, function(x) all(is.numeric(x)))],
                  variable.name='Sample',
                  value.name='Intensity')
  DT.long=data.table::data.table(DT.long)
  DT.long=DT.long[DT.long$Intensity>0,]
  return(DT.long)
}
